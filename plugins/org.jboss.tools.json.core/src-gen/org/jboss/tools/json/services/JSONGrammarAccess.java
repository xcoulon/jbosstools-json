/*
* generated by Xtext
*/
package org.jboss.tools.json.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class JSONGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class JSONModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "JSONModel");
		private final Assignment cRootObjectAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cRootObjectJSONObjectParserRuleCall_0 = (RuleCall)cRootObjectAssignment.eContents().get(0);
		
		//JSONModel:
		//	rootObject=JSONObject?;
		public ParserRule getRule() { return rule; }

		//rootObject=JSONObject?
		public Assignment getRootObjectAssignment() { return cRootObjectAssignment; }

		//JSONObject
		public RuleCall getRootObjectJSONObjectParserRuleCall_0() { return cRootObjectJSONObjectParserRuleCall_0; }
	}

	public class JSONObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "JSONObject");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cJSONObjectAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cPairsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cPairsPairParserRuleCall_2_0_0 = (RuleCall)cPairsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final RuleCall cTERMINAL_COMMATerminalRuleCall_2_1_0 = (RuleCall)cGroup_2_1.eContents().get(0);
		private final Assignment cPairsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cPairsPairParserRuleCall_2_1_1_0 = (RuleCall)cPairsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//JSONObject hidden(WS):
		//	{JSONObject} "{" (pairs+=Pair (TERMINAL_COMMA pairs+=Pair)*)? "}";
		public ParserRule getRule() { return rule; }

		//{JSONObject} "{" (pairs+=Pair (TERMINAL_COMMA pairs+=Pair)*)? "}"
		public Group getGroup() { return cGroup; }

		//{JSONObject}
		public Action getJSONObjectAction_0() { return cJSONObjectAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(pairs+=Pair (TERMINAL_COMMA pairs+=Pair)*)?
		public Group getGroup_2() { return cGroup_2; }

		//pairs+=Pair
		public Assignment getPairsAssignment_2_0() { return cPairsAssignment_2_0; }

		//Pair
		public RuleCall getPairsPairParserRuleCall_2_0_0() { return cPairsPairParserRuleCall_2_0_0; }

		//(TERMINAL_COMMA pairs+=Pair)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//TERMINAL_COMMA
		public RuleCall getTERMINAL_COMMATerminalRuleCall_2_1_0() { return cTERMINAL_COMMATerminalRuleCall_2_1_0; }

		//pairs+=Pair
		public Assignment getPairsAssignment_2_1_1() { return cPairsAssignment_2_1_1; }

		//Pair
		public RuleCall getPairsPairParserRuleCall_2_1_1_0() { return cPairsPairParserRuleCall_2_1_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class PairElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Pair");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeyKeyParserRuleCall_0_0 = (RuleCall)cKeyAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueValueParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//Pair hidden(WS):
		//	key=Key ":" value=Value;
		public ParserRule getRule() { return rule; }

		//key=Key ":" value=Value
		public Group getGroup() { return cGroup; }

		//key=Key
		public Assignment getKeyAssignment_0() { return cKeyAssignment_0; }

		//Key
		public RuleCall getKeyKeyParserRuleCall_0_0() { return cKeyKeyParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//value=Value
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//Value
		public RuleCall getValueValueParserRuleCall_2_0() { return cValueValueParserRuleCall_2_0; }
	}

	public class KeyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Key");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameTERMINAL_QUOTED_CHARSTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//// *********************
		//// Key: a quoted char
		//// *********************
		//Key:
		//	name=TERMINAL_QUOTED_CHARS;
		public ParserRule getRule() { return rule; }

		//name=TERMINAL_QUOTED_CHARS
		public Assignment getNameAssignment() { return cNameAssignment; }

		//TERMINAL_QUOTED_CHARS
		public RuleCall getNameTERMINAL_QUOTED_CHARSTerminalRuleCall_0() { return cNameTERMINAL_QUOTED_CHARSTerminalRuleCall_0; }
	}

	public class JSONArrayElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "JSONArray");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementsValueParserRuleCall_1_0 = (RuleCall)cElementsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cTERMINAL_COMMATerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cElementsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cElementsValueParserRuleCall_2_1_0 = (RuleCall)cElementsAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// *********************
		//// An Array is an ordered collection of values. 
		//// An Array begins with[(left bracket) and ends with](right bracket). 
		//// Values are separated by ,(comma).
		//// *********************
		//JSONArray hidden(WS):
		//	"[" elements+=Value (TERMINAL_COMMA elements+=Value)* "]";
		public ParserRule getRule() { return rule; }

		//"[" elements+=Value (TERMINAL_COMMA elements+=Value)* "]"
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//elements+=Value
		public Assignment getElementsAssignment_1() { return cElementsAssignment_1; }

		//Value
		public RuleCall getElementsValueParserRuleCall_1_0() { return cElementsValueParserRuleCall_1_0; }

		//(TERMINAL_COMMA elements+=Value)*
		public Group getGroup_2() { return cGroup_2; }

		//TERMINAL_COMMA
		public RuleCall getTERMINAL_COMMATerminalRuleCall_2_0() { return cTERMINAL_COMMATerminalRuleCall_2_0; }

		//elements+=Value
		public Assignment getElementsAssignment_2_1() { return cElementsAssignment_2_1; }

		//Value
		public RuleCall getElementsValueParserRuleCall_2_1_0() { return cElementsValueParserRuleCall_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}

	public class ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cJSONArrayParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cJSONObjectParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cJSONSimpleValueParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// *********************
		//// A value can be a string in double quotes, or a number, 
		//// or true or false or null, or an object or an array. 
		//// These structures can be nested.
		//// *********************
		//Value returns ecore::EObject:
		//	JSONArray | JSONObject | JSONSimpleValue;
		public ParserRule getRule() { return rule; }

		//JSONArray | JSONObject | JSONSimpleValue
		public Alternatives getAlternatives() { return cAlternatives; }

		//JSONArray
		public RuleCall getJSONArrayParserRuleCall_0() { return cJSONArrayParserRuleCall_0; }

		//JSONObject
		public RuleCall getJSONObjectParserRuleCall_1() { return cJSONObjectParserRuleCall_1; }

		//JSONSimpleValue
		public RuleCall getJSONSimpleValueParserRuleCall_2() { return cJSONSimpleValueParserRuleCall_2; }
	}

	public class JSONSimpleValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "JSONSimpleValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cQuotedCharsParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNumberParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cNullParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTrueParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cFalseParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//JSONSimpleValue:
		//	QuotedChars | Number | Null | True | False;
		public ParserRule getRule() { return rule; }

		//QuotedChars | Number | Null | True | False
		public Alternatives getAlternatives() { return cAlternatives; }

		//QuotedChars
		public RuleCall getQuotedCharsParserRuleCall_0() { return cQuotedCharsParserRuleCall_0; }

		//Number
		public RuleCall getNumberParserRuleCall_1() { return cNumberParserRuleCall_1; }

		//Null
		public RuleCall getNullParserRuleCall_2() { return cNullParserRuleCall_2; }

		//True
		public RuleCall getTrueParserRuleCall_3() { return cTrueParserRuleCall_3; }

		//False
		public RuleCall getFalseParserRuleCall_4() { return cFalseParserRuleCall_4; }
	}

	public class QuotedCharsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuotedChars");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueTERMINAL_QUOTED_CHARSTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//// *********************
		//// CHARS (not using 'STRING' as an imported terminal rule with the same name already exists)
		//// 'CHARS' is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapes. 
		//// A character is represented as a single character string. A string is very much like a C or Java string.
		//// *********************
		//QuotedChars:
		//	value=TERMINAL_QUOTED_CHARS;
		public ParserRule getRule() { return rule; }

		//value=TERMINAL_QUOTED_CHARS
		public Assignment getValueAssignment() { return cValueAssignment; }

		//TERMINAL_QUOTED_CHARS
		public RuleCall getValueTERMINAL_QUOTED_CHARSTerminalRuleCall_0() { return cValueTERMINAL_QUOTED_CHARSTerminalRuleCall_0; }
	}

	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Number");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueTERMINAL_NUMBERTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//// *********************
		//// NUMBER
		//// A number is very much like a C or Java number, except that the octal and hexadecimal formats are not used.
		//// *********************
		//Number:
		//	value=TERMINAL_NUMBER;
		public ParserRule getRule() { return rule; }

		//value=TERMINAL_NUMBER
		public Assignment getValueAssignment() { return cValueAssignment; }

		//TERMINAL_NUMBER
		public RuleCall getValueTERMINAL_NUMBERTerminalRuleCall_0() { return cValueTERMINAL_NUMBERTerminalRuleCall_0; }
	}

	public class NullElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Null");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueTERMINAL_NULLTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//// *********************
		//// null, true and false
		//// *********************
		//Null:
		//	value=TERMINAL_NULL;
		public ParserRule getRule() { return rule; }

		//value=TERMINAL_NULL
		public Assignment getValueAssignment() { return cValueAssignment; }

		//TERMINAL_NULL
		public RuleCall getValueTERMINAL_NULLTerminalRuleCall_0() { return cValueTERMINAL_NULLTerminalRuleCall_0; }
	}

	public class FalseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "False");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueTERMINAL_FALSETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//False:
		//	value=TERMINAL_FALSE;
		public ParserRule getRule() { return rule; }

		//value=TERMINAL_FALSE
		public Assignment getValueAssignment() { return cValueAssignment; }

		//TERMINAL_FALSE
		public RuleCall getValueTERMINAL_FALSETerminalRuleCall_0() { return cValueTERMINAL_FALSETerminalRuleCall_0; }
	}

	public class TrueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "True");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueTERMINAL_TRUETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//True:
		//	value=TERMINAL_TRUE;
		public ParserRule getRule() { return rule; }

		//value=TERMINAL_TRUE
		public Assignment getValueAssignment() { return cValueAssignment; }

		//TERMINAL_TRUE
		public RuleCall getValueTERMINAL_TRUETerminalRuleCall_0() { return cValueTERMINAL_TRUETerminalRuleCall_0; }
	}
	
	
	private final JSONModelElements pJSONModel;
	private final JSONObjectElements pJSONObject;
	private final PairElements pPair;
	private final KeyElements pKey;
	private final JSONArrayElements pJSONArray;
	private final ValueElements pValue;
	private final JSONSimpleValueElements pJSONSimpleValue;
	private final QuotedCharsElements pQuotedChars;
	private final TerminalRule tTERMINAL_QUOTED_CHARS;
	private final NumberElements pNumber;
	private final TerminalRule tTERMINAL_NUMBER;
	private final TerminalRule tDIGIT_1_9;
	private final TerminalRule tDIGIT;
	private final TerminalRule tEXP;
	private final TerminalRule tPLUS_MINUS;
	private final NullElements pNull;
	private final TerminalRule tTERMINAL_NULL;
	private final FalseElements pFalse;
	private final TerminalRule tTERMINAL_FALSE;
	private final TrueElements pTrue;
	private final TerminalRule tTERMINAL_TRUE;
	private final TerminalRule tTERMINAL_COMMA;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public JSONGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pJSONModel = new JSONModelElements();
		this.pJSONObject = new JSONObjectElements();
		this.pPair = new PairElements();
		this.pKey = new KeyElements();
		this.pJSONArray = new JSONArrayElements();
		this.pValue = new ValueElements();
		this.pJSONSimpleValue = new JSONSimpleValueElements();
		this.pQuotedChars = new QuotedCharsElements();
		this.tTERMINAL_QUOTED_CHARS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TERMINAL_QUOTED_CHARS");
		this.pNumber = new NumberElements();
		this.tTERMINAL_NUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TERMINAL_NUMBER");
		this.tDIGIT_1_9 = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DIGIT_1_9");
		this.tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DIGIT");
		this.tEXP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EXP");
		this.tPLUS_MINUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PLUS_MINUS");
		this.pNull = new NullElements();
		this.tTERMINAL_NULL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TERMINAL_NULL");
		this.pFalse = new FalseElements();
		this.tTERMINAL_FALSE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TERMINAL_FALSE");
		this.pTrue = new TrueElements();
		this.tTERMINAL_TRUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TERMINAL_TRUE");
		this.tTERMINAL_COMMA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TERMINAL_COMMA");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.jboss.tools.json.JSON".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//JSONModel:
	//	rootObject=JSONObject?;
	public JSONModelElements getJSONModelAccess() {
		return pJSONModel;
	}
	
	public ParserRule getJSONModelRule() {
		return getJSONModelAccess().getRule();
	}

	//JSONObject hidden(WS):
	//	{JSONObject} "{" (pairs+=Pair (TERMINAL_COMMA pairs+=Pair)*)? "}";
	public JSONObjectElements getJSONObjectAccess() {
		return pJSONObject;
	}
	
	public ParserRule getJSONObjectRule() {
		return getJSONObjectAccess().getRule();
	}

	//Pair hidden(WS):
	//	key=Key ":" value=Value;
	public PairElements getPairAccess() {
		return pPair;
	}
	
	public ParserRule getPairRule() {
		return getPairAccess().getRule();
	}

	//// *********************
	//// Key: a quoted char
	//// *********************
	//Key:
	//	name=TERMINAL_QUOTED_CHARS;
	public KeyElements getKeyAccess() {
		return pKey;
	}
	
	public ParserRule getKeyRule() {
		return getKeyAccess().getRule();
	}

	//// *********************
	//// An Array is an ordered collection of values. 
	//// An Array begins with[(left bracket) and ends with](right bracket). 
	//// Values are separated by ,(comma).
	//// *********************
	//JSONArray hidden(WS):
	//	"[" elements+=Value (TERMINAL_COMMA elements+=Value)* "]";
	public JSONArrayElements getJSONArrayAccess() {
		return pJSONArray;
	}
	
	public ParserRule getJSONArrayRule() {
		return getJSONArrayAccess().getRule();
	}

	//// *********************
	//// A value can be a string in double quotes, or a number, 
	//// or true or false or null, or an object or an array. 
	//// These structures can be nested.
	//// *********************
	//Value returns ecore::EObject:
	//	JSONArray | JSONObject | JSONSimpleValue;
	public ValueElements getValueAccess() {
		return pValue;
	}
	
	public ParserRule getValueRule() {
		return getValueAccess().getRule();
	}

	//JSONSimpleValue:
	//	QuotedChars | Number | Null | True | False;
	public JSONSimpleValueElements getJSONSimpleValueAccess() {
		return pJSONSimpleValue;
	}
	
	public ParserRule getJSONSimpleValueRule() {
		return getJSONSimpleValueAccess().getRule();
	}

	//// *********************
	//// CHARS (not using 'STRING' as an imported terminal rule with the same name already exists)
	//// 'CHARS' is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapes. 
	//// A character is represented as a single character string. A string is very much like a C or Java string.
	//// *********************
	//QuotedChars:
	//	value=TERMINAL_QUOTED_CHARS;
	public QuotedCharsElements getQuotedCharsAccess() {
		return pQuotedChars;
	}
	
	public ParserRule getQuotedCharsRule() {
		return getQuotedCharsAccess().getRule();
	}

	//terminal TERMINAL_QUOTED_CHARS:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"";
	public TerminalRule getTERMINAL_QUOTED_CHARSRule() {
		return tTERMINAL_QUOTED_CHARS;
	} 

	//// *********************
	//// NUMBER
	//// A number is very much like a C or Java number, except that the octal and hexadecimal formats are not used.
	//// *********************
	//Number:
	//	value=TERMINAL_NUMBER;
	public NumberElements getNumberAccess() {
		return pNumber;
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}

	//terminal TERMINAL_NUMBER:
	//	"-"? ("0" | DIGIT_1_9 DIGIT*) ("." DIGIT+)? (EXP PLUS_MINUS? DIGIT+)?;
	public TerminalRule getTERMINAL_NUMBERRule() {
		return tTERMINAL_NUMBER;
	} 

	//terminal fragment DIGIT_1_9:
	//	"1".."9";
	public TerminalRule getDIGIT_1_9Rule() {
		return tDIGIT_1_9;
	} 

	//terminal fragment DIGIT:
	//	"0".."9";
	public TerminalRule getDIGITRule() {
		return tDIGIT;
	} 

	//terminal fragment EXP:
	//	"e" | "E";
	public TerminalRule getEXPRule() {
		return tEXP;
	} 

	//terminal fragment PLUS_MINUS:
	//	"+" | "-";
	public TerminalRule getPLUS_MINUSRule() {
		return tPLUS_MINUS;
	} 

	//// *********************
	//// null, true and false
	//// *********************
	//Null:
	//	value=TERMINAL_NULL;
	public NullElements getNullAccess() {
		return pNull;
	}
	
	public ParserRule getNullRule() {
		return getNullAccess().getRule();
	}

	//terminal TERMINAL_NULL:
	//	"null";
	public TerminalRule getTERMINAL_NULLRule() {
		return tTERMINAL_NULL;
	} 

	//False:
	//	value=TERMINAL_FALSE;
	public FalseElements getFalseAccess() {
		return pFalse;
	}
	
	public ParserRule getFalseRule() {
		return getFalseAccess().getRule();
	}

	//terminal TERMINAL_FALSE:
	//	"false";
	public TerminalRule getTERMINAL_FALSERule() {
		return tTERMINAL_FALSE;
	} 

	//True:
	//	value=TERMINAL_TRUE;
	public TrueElements getTrueAccess() {
		return pTrue;
	}
	
	public ParserRule getTrueRule() {
		return getTrueAccess().getRule();
	}

	//terminal TERMINAL_TRUE:
	//	"true";
	public TerminalRule getTERMINAL_TRUERule() {
		return tTERMINAL_TRUE;
	} 

	//terminal TERMINAL_COMMA:
	//	",";
	public TerminalRule getTERMINAL_COMMARule() {
		return tTERMINAL_COMMA;
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\""))* "\"" | "\'" ("\\" .
	//	/ * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
